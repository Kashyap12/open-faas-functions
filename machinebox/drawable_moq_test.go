// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package function

import (
	"github.com/llgcode/draw2d"
	"image/color"
	"sync"
)

var (
	lockDrawableMockClose          sync.RWMutex
	lockDrawableMockFillStroke     sync.RWMutex
	lockDrawableMockLineTo         sync.RWMutex
	lockDrawableMockMoveTo         sync.RWMutex
	lockDrawableMockSetFillColor   sync.RWMutex
	lockDrawableMockSetLineWidth   sync.RWMutex
	lockDrawableMockSetStrokeColor sync.RWMutex
)

// DrawableMock is a mock implementation of Drawable.
//
//     func TestSomethingThatUsesDrawable(t *testing.T) {
//
//         // make and configure a mocked Drawable
//         mockedDrawable := &DrawableMock{
//             CloseFunc: func()  {
// 	               panic("TODO: mock out the Close method")
//             },
//             FillStrokeFunc: func(paths ...*draw2d.Path)  {
// 	               panic("TODO: mock out the FillStroke method")
//             },
//             LineToFunc: func(x float64, y float64)  {
// 	               panic("TODO: mock out the LineTo method")
//             },
//             MoveToFunc: func(x float64, y float64)  {
// 	               panic("TODO: mock out the MoveTo method")
//             },
//             SetFillColorFunc: func(in1 color.Color)  {
// 	               panic("TODO: mock out the SetFillColor method")
//             },
//             SetLineWidthFunc: func(in1 float64)  {
// 	               panic("TODO: mock out the SetLineWidth method")
//             },
//             SetStrokeColorFunc: func(in1 color.Color)  {
// 	               panic("TODO: mock out the SetStrokeColor method")
//             },
//         }
//
//         // TODO: use mockedDrawable in code that requires Drawable
//         //       and then make assertions.
//
//     }
type DrawableMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// FillStrokeFunc mocks the FillStroke method.
	FillStrokeFunc func(paths ...*draw2d.Path)

	// LineToFunc mocks the LineTo method.
	LineToFunc func(x float64, y float64)

	// MoveToFunc mocks the MoveTo method.
	MoveToFunc func(x float64, y float64)

	// SetFillColorFunc mocks the SetFillColor method.
	SetFillColorFunc func(in1 color.Color)

	// SetLineWidthFunc mocks the SetLineWidth method.
	SetLineWidthFunc func(in1 float64)

	// SetStrokeColorFunc mocks the SetStrokeColor method.
	SetStrokeColorFunc func(in1 color.Color)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// FillStroke holds details about calls to the FillStroke method.
		FillStroke []struct {
			// Paths is the paths argument value.
			Paths []*draw2d.Path
		}
		// LineTo holds details about calls to the LineTo method.
		LineTo []struct {
			// X is the x argument value.
			X float64
			// Y is the y argument value.
			Y float64
		}
		// MoveTo holds details about calls to the MoveTo method.
		MoveTo []struct {
			// X is the x argument value.
			X float64
			// Y is the y argument value.
			Y float64
		}
		// SetFillColor holds details about calls to the SetFillColor method.
		SetFillColor []struct {
			// In1 is the in1 argument value.
			In1 color.Color
		}
		// SetLineWidth holds details about calls to the SetLineWidth method.
		SetLineWidth []struct {
			// In1 is the in1 argument value.
			In1 float64
		}
		// SetStrokeColor holds details about calls to the SetStrokeColor method.
		SetStrokeColor []struct {
			// In1 is the in1 argument value.
			In1 color.Color
		}
	}
}

// Close calls CloseFunc.
func (mock *DrawableMock) Close() {
	if mock.CloseFunc == nil {
		panic("moq: DrawableMock.CloseFunc is nil but Drawable.Close was just called")
	}
	callInfo := struct {
	}{}
	lockDrawableMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockDrawableMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedDrawable.CloseCalls())
func (mock *DrawableMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockDrawableMockClose.RLock()
	calls = mock.calls.Close
	lockDrawableMockClose.RUnlock()
	return calls
}

// FillStroke calls FillStrokeFunc.
func (mock *DrawableMock) FillStroke(paths ...*draw2d.Path) {
	if mock.FillStrokeFunc == nil {
		panic("moq: DrawableMock.FillStrokeFunc is nil but Drawable.FillStroke was just called")
	}
	callInfo := struct {
		Paths []*draw2d.Path
	}{
		Paths: paths,
	}
	lockDrawableMockFillStroke.Lock()
	mock.calls.FillStroke = append(mock.calls.FillStroke, callInfo)
	lockDrawableMockFillStroke.Unlock()
	mock.FillStrokeFunc(paths...)
}

// FillStrokeCalls gets all the calls that were made to FillStroke.
// Check the length with:
//     len(mockedDrawable.FillStrokeCalls())
func (mock *DrawableMock) FillStrokeCalls() []struct {
	Paths []*draw2d.Path
} {
	var calls []struct {
		Paths []*draw2d.Path
	}
	lockDrawableMockFillStroke.RLock()
	calls = mock.calls.FillStroke
	lockDrawableMockFillStroke.RUnlock()
	return calls
}

// LineTo calls LineToFunc.
func (mock *DrawableMock) LineTo(x float64, y float64) {
	if mock.LineToFunc == nil {
		panic("moq: DrawableMock.LineToFunc is nil but Drawable.LineTo was just called")
	}
	callInfo := struct {
		X float64
		Y float64
	}{
		X: x,
		Y: y,
	}
	lockDrawableMockLineTo.Lock()
	mock.calls.LineTo = append(mock.calls.LineTo, callInfo)
	lockDrawableMockLineTo.Unlock()
	mock.LineToFunc(x, y)
}

// LineToCalls gets all the calls that were made to LineTo.
// Check the length with:
//     len(mockedDrawable.LineToCalls())
func (mock *DrawableMock) LineToCalls() []struct {
	X float64
	Y float64
} {
	var calls []struct {
		X float64
		Y float64
	}
	lockDrawableMockLineTo.RLock()
	calls = mock.calls.LineTo
	lockDrawableMockLineTo.RUnlock()
	return calls
}

// MoveTo calls MoveToFunc.
func (mock *DrawableMock) MoveTo(x float64, y float64) {
	if mock.MoveToFunc == nil {
		panic("moq: DrawableMock.MoveToFunc is nil but Drawable.MoveTo was just called")
	}
	callInfo := struct {
		X float64
		Y float64
	}{
		X: x,
		Y: y,
	}
	lockDrawableMockMoveTo.Lock()
	mock.calls.MoveTo = append(mock.calls.MoveTo, callInfo)
	lockDrawableMockMoveTo.Unlock()
	mock.MoveToFunc(x, y)
}

// MoveToCalls gets all the calls that were made to MoveTo.
// Check the length with:
//     len(mockedDrawable.MoveToCalls())
func (mock *DrawableMock) MoveToCalls() []struct {
	X float64
	Y float64
} {
	var calls []struct {
		X float64
		Y float64
	}
	lockDrawableMockMoveTo.RLock()
	calls = mock.calls.MoveTo
	lockDrawableMockMoveTo.RUnlock()
	return calls
}

// SetFillColor calls SetFillColorFunc.
func (mock *DrawableMock) SetFillColor(in1 color.Color) {
	if mock.SetFillColorFunc == nil {
		panic("moq: DrawableMock.SetFillColorFunc is nil but Drawable.SetFillColor was just called")
	}
	callInfo := struct {
		In1 color.Color
	}{
		In1: in1,
	}
	lockDrawableMockSetFillColor.Lock()
	mock.calls.SetFillColor = append(mock.calls.SetFillColor, callInfo)
	lockDrawableMockSetFillColor.Unlock()
	mock.SetFillColorFunc(in1)
}

// SetFillColorCalls gets all the calls that were made to SetFillColor.
// Check the length with:
//     len(mockedDrawable.SetFillColorCalls())
func (mock *DrawableMock) SetFillColorCalls() []struct {
	In1 color.Color
} {
	var calls []struct {
		In1 color.Color
	}
	lockDrawableMockSetFillColor.RLock()
	calls = mock.calls.SetFillColor
	lockDrawableMockSetFillColor.RUnlock()
	return calls
}

// SetLineWidth calls SetLineWidthFunc.
func (mock *DrawableMock) SetLineWidth(in1 float64) {
	if mock.SetLineWidthFunc == nil {
		panic("moq: DrawableMock.SetLineWidthFunc is nil but Drawable.SetLineWidth was just called")
	}
	callInfo := struct {
		In1 float64
	}{
		In1: in1,
	}
	lockDrawableMockSetLineWidth.Lock()
	mock.calls.SetLineWidth = append(mock.calls.SetLineWidth, callInfo)
	lockDrawableMockSetLineWidth.Unlock()
	mock.SetLineWidthFunc(in1)
}

// SetLineWidthCalls gets all the calls that were made to SetLineWidth.
// Check the length with:
//     len(mockedDrawable.SetLineWidthCalls())
func (mock *DrawableMock) SetLineWidthCalls() []struct {
	In1 float64
} {
	var calls []struct {
		In1 float64
	}
	lockDrawableMockSetLineWidth.RLock()
	calls = mock.calls.SetLineWidth
	lockDrawableMockSetLineWidth.RUnlock()
	return calls
}

// SetStrokeColor calls SetStrokeColorFunc.
func (mock *DrawableMock) SetStrokeColor(in1 color.Color) {
	if mock.SetStrokeColorFunc == nil {
		panic("moq: DrawableMock.SetStrokeColorFunc is nil but Drawable.SetStrokeColor was just called")
	}
	callInfo := struct {
		In1 color.Color
	}{
		In1: in1,
	}
	lockDrawableMockSetStrokeColor.Lock()
	mock.calls.SetStrokeColor = append(mock.calls.SetStrokeColor, callInfo)
	lockDrawableMockSetStrokeColor.Unlock()
	mock.SetStrokeColorFunc(in1)
}

// SetStrokeColorCalls gets all the calls that were made to SetStrokeColor.
// Check the length with:
//     len(mockedDrawable.SetStrokeColorCalls())
func (mock *DrawableMock) SetStrokeColorCalls() []struct {
	In1 color.Color
} {
	var calls []struct {
		In1 color.Color
	}
	lockDrawableMockSetStrokeColor.RLock()
	calls = mock.calls.SetStrokeColor
	lockDrawableMockSetStrokeColor.RUnlock()
	return calls
}
